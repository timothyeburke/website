<div class="padded blog">
<!--
    <div class="entry">
        <h2>Blog title</h2>
        <p>11/11/11</p>
        <p>
            <a href="foo.com" target="_blank">url goes here</a>
        </p>
        <p>
            Blog entry goes here.
        </p>
    </div>
-->
    <div class="entry">
        <h2>Joining Collections</h2>
        <p>10/13/2015</p>
        <p>
            It's been a while since I posted. I'll be musing more soon. For now I wanted to talk about my latest favorite pet peeve. Consider the following code:
        </p>
        <pre>
// Array of data from API
const procedures = [n elements]

// Array of data from protected API
const patients = [n-ish elements]

_.each(procedures, (procedure) => {
    procedure.patient = _.find(patients, {id: procedure.patient_id})
})</pre>
        <p>
            This looks innocent enough. At Kit Check, we have a general API that stores most of the data for the application, but some data, protected health information, must be stored separately, encrypted at rest, with more limited access requirements, and all that jazz. The UI must fetch and join the PHI data when necessary from separate servers. But there's a problem with this code.
        </p>
        <p>
            Since there are roughly the same number of elements in both arrays, this is approximately a O(n<sup>2</sup>) function - or, for every element in procedures, at worst, we must search through every element in patients. If each array were 10 elements, you must perform 100 operations. We do this a lot all over our UI code. I've started slowly cleaning them up as I come across them.
        </p>
        <p>
            Here's a better way:
        </p>
        <pre>
const patientsObj = _.reduce(patients, (result, n) => {
    result[n.id] = n
    return result
}, {})

_.each(procedures, (procedure) => {
    procedure.patient = patientsObj[procedure.patient_id]
})</pre>
        <p>
            This yeilds the same result, but it does two linear passes, O(2n) or just O(n) or just twenty operations for 10 elements in each array. This is because fetching a keyed item from a hash table (JS objects are key/value hashes) is a constant time operation. The code is a tiny bit harder to read, but when those numbers of elements go up from the 10s to the 100s, the number of computations falls significantly, and improves performance of the browser on slower hardware.
        </p>
    </div>

    <div class="entry">
        <h2>Linked Lists vs. Arrays</h2>
        <p>11/21/2014</p>
        <p>
            This is one of my favorite interview questions: Please explain the difference between a linked list and an array, and give examples of when you would use each.
        </p>
        <p>
            I can't emphasize enough how powerful this question is. I'm absolutely dumbfounded by the number of people with Computer Science degrees that I've inverviewed who can't answer this question. This is CS101. Basic data structures. For a while, my boss started using this question on technical phone screens after I had asked it in a bunch of interviews. Now we use it during technical interviews when candidates come in. While I missed this particular interview, I was pleased to hear that we today had gotten one of the best, most thoughtful answers to this question that we've ever encountered. The candidate not only demonstrated an understanding of the difference and provided use cases, he discussed architectural caveats, things that can go wrong in implementations, and overhead costs that big-O analysis would not account for. 
        </p>
        <p>
            I are pleased.
        </p>
    </div>

    <div class="entry">
        <h2>Falsehoods programmers believe about time</h2>
        <p>9/11/2014</p>
        <p>
            <a href="http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time" target="_blank">infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time</a>
        </p>
        <p>
            Software engineers often make mistakes when having to deal with time. Many assume there is only one time zone (the one they are in) or that all computers have precisely set clocks. As you learn in a good distributed systems class, time and synchronization is a difficult task. This article is a reminder of the great many things developers often get wrong when it comes to time and date.
        </p>
    </div>

    <div class="entry">
        <h2>Speeding up AngularJS apps with simple optimizations</h2>
        <p>8/9/2014</p>
        <p>
            <a href="http://www.binpress.com/tutorial/speeding-up-angular-js-with-simple-optimizations/135" target="_blank">www.binpress.com/tutorial/speeding-up-angular-js-with-simple-optimizations/135</a>
        </p>
        <p>
            As amazing as AngularJS is, it is absolutely possible to write badly performing code. Like the article I link on 12/13/2013, <i>Your jQuery: Now With 67% Less Suck</i>, there are ways you can optimize your code based on use. I particularly like the one-time binding syntax and the explanation of how to use $scope.$apply(). 
        </p>
    </div>

    <div class="entry">
        <h2>Show Full Directory Path in Mac OS X Finder Window Title Bars</h2>
        <p>3/20/2014</p>
        <p>
            <a href="http://osxdaily.com/2007/12/02/show-full-directory-path-in-finder-window-title-bars/" target="_blank">osxdaily.com/2007/12/02/show-full-directory-path-in-finder-window-title-bars</a>
        </p>
        <p>
            This is a handy trick I found for showing the full directory path in the title bar of Finder windows in OS X. Apple works hard to abstract away the idea of a file system for the normal user, and this is especially true on their iOS devices. That bein said, as a developer, I spend a significant amount of time using a command line interface and navigating the file system that way. Having Finder show me exact file paths makes it easier to get to where I need to go.
        </p>
    </div>

    <div class="entry">
        <h2>JSON.stringify() Can Pretty-print</h2>
        <p>3/19/2014</p>
        <p>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a>
        </p>
        <p>
            Mind. Blown. Somehow I never new that JSON.stringify() could pretty. This is amazing.
        </p>
    </div>

    <div class="entry">
        <h2>Using Colors in CSS (Specifically HSL)</h2>
        <p>3/7/2014</p>
        <p>
            <a href="http://vormplus.be/blog/article/using-colors-in-css" target="_blank">vormplus.be/blog/article/using-colors-in-css</a>
        </p>
        <p>
            This is a great article on how colors work in CSS. The biggest surprise to me was that CSS supports the HSL (hue, saturation, lightness) color space. After doing a research project in grad school that required me to learn using HSL (because it's a better way to map two or three independent variables), I've always thought about color in terms of HSL instead of RGB. Over time as I've become better with RGB through doing web design and implementation work, but it was nice to find that old familiar HSL as part of standard CSS. 
        </p>
    </div>

    <div class="entry">
        <h2>Casting Variables in JavaScript</h2>
        <p>3/5/2014</p>
        <p>
            <a href="http://jsperf.com/typecast-variable" target="_blank">jsperf.com/typecast-variable</a>
        </p>
        <p>
            What's better: faster code or readable code? The best answer is almost always "it depends." Given the following setup, there are a bunch of different ways to convert a string representation of a number into a number in JavaScript. Consider the following code: 
        </p>
        <pre>
var str = "90";

var num = +str;
var num = str * 1;
var num = parseFloat(str);
var num = parseInt(str);
var num = parseFloat(num).toFixed(0);</pre>
        <p>
            At <a href="http://ringtaildesign.com" target="_blank">Ringtail Design</a>, we had a developer who insisted on using lines like <span class="mono">+str;</span> and <span class="mono">str * 1</span> to convert those number strings into numbers. His argument was that using those esoteric methods is faster (see the linked performance tests). That only really held true for Opera (which was his browser of choice), and anyway it was very unreadable code. This led to us entering a set of rules into our coding guidelines that specifically said that it was desirable to prefer code readability (using <span class="mono">parse</span> methods) over speed in nearly all cases, unless the specific use case called for it - running thousands of conversions per second, and then performance test first using the suite of supported browsers to determine which method is most performant based on the target browsers. 
        </p>
    </div>

    <div class="entry">
        <h2>D3 General Update Pattern</h2>
        <p>2/18/2014</p>
        <p>
            <a href="http://bl.ocks.org/mbostock/3808218" target="_blank">bl.ocks.org/mbostock/3808218</a>
        </p>
        <p>
            When I was first learning to tinker with d3, I found the data element lifecycle in d3 a bit confusing. Following this brief code example made it so much easier.
        </p>
    </div>

    <div class="entry">
        <h2>A Useless Micro-Optimization</h2>
        <p>2/4/2014</p>
        <p>
            <a href="http://jsperf.com/jquery-document-body-vs-find-body" target="_blank">jsperf.com/jquery-document-body-vs-find-body</a>
        </p>
        <p>
            When using jQuery, you can <span class="mono">$(document.body)</span> instead of <span class="mono">$('body')</span> or <span class="mono">$(document).find('body')</span>? Also, it's faster. Then again, you should only need to do this once in any given page (saving jQuery-selected elements is a thing you should be doing), so this doesn't buy you much... but isn't it neat?
        </p>
    </div>

    <div class="entry">
        <h2>Your jQuery: Now With 67% Less Suck</h2>
        <p>12/13/2013</p>
        <p>
            <a href="http://24ways.org/2011/your-jquery-now-with-less-suck/" target="_blank">24ways.org/2011/your-jquery-now-with-less-suck</a>
        </p>
        <p>
            This is by far one of my favorite articles ever about jQuery. It focuses on simple ways to write better jQuery code that is significantly faster. Things like breaking apart compound selectors into chained methods for better performance, storing away jQuery references for re-use, and event delegation to reduce the number of event listeners on a page. I've written some bad jQuery code in the past (we all have), and this helped me raise that bar a lot. It's also where I originally got the idea for my jQuery "Expert" interview question.  
        </p>
    </div>

    <div class="entry">
        <h2>The jQuery Expert</h2>
        <p>9/10/2013</p>
        <p>
            Today we were intervewing a senior-level candidate who has spent the last 10 years or so doing web development. When we were probing to figure out his skill level with various tools and languages, he remarked that he had been using jQuery since it first came out and that he was a 10 out of 10 expert on it. I was skeptical given some of his other answers. I wrote these two lines on the whiteboard and asked him to explain the difference between them and why one was better than the other.
        </p>
        <pre>
$("#foo .bar").show();
$("#foo").find(".bar").show();</pre>
        <p>
            He could not. We did not hire him.
        </p>
        <p>
            In 7 years of using the jQuery library, had he never opened the un-minimized source and read through it? There's some magical stuff in there. There's also some pretty basic facade. The second one is faster because the id selector <span class="mono">$("#foo")</span> maps directly to the <span class="mono">document.getElementById()</span> method supported by every browser. The <span class="mono">find(".bar")</span> does something similar in browsers that support <span class="mono">document.getElementsByClassName()</span> and does a basic walk in browsers that do not *cough* IE *cough*. The compound selector <span class="mono">$("#foo bar")</span> forces jQuery to walk the entire DOM tree in order to find matching elements, which can be very slow, especially if done repeatedly. 
        </p>
    </div>
</div>
